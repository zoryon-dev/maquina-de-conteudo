/**
 * Apify Service for Wizard
 *
 * Video transcription integration using Apify YouTube Transcript actor.
 *
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ARCHITECTURE NOTES
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * - Uses Apify API for YouTube video transcription
 * - Graceful degradation: returns null if not configured
 * - Extracts transcript text with timestamps
 * - Handles errors without blocking the wizard job
 */

import type { VideoTranscription, ServiceResult } from "./types";

// ============================================================================
// CONFIGURATION
// ============================================================================

/**
 * Apify API token from environment.
 * Supports both APIFY_API_TOKEN (SDK default) and APIFY_API_KEY (common alternative).
 */
const APIFY_API_TOKEN = process.env.APIFY_API_TOKEN || process.env.APIFY_API_KEY;

/**
 * Apify API endpoint.
 */
const APIFY_API_URL = "https://api.apify.com/v2/acts";

/**
 * YouTube Transcript Actor ID on Apify.
 *
 * Uses the "streamrecraper/youtube-transcript" actor which extracts
 * subtitles/transcripts from YouTube videos with all metadata.
 */
const YOUTUBE_TRANSCRIPT_ACTOR_ID = "streamrecraper/youtube-transcript";

/**
 * Check if Apify is configured.
 */
export function isApifyConfigured(): boolean {
  return !!APIFY_API_TOKEN;
}

// ============================================================================
// VIDEO TRANSCRIPTION
// ============================================================================

/**
 * Transcribe a YouTube video using Apify.
 *
 * @param videoUrl - Full YouTube video URL or video ID
 * @returns Service result with transcription data or null
 *
 * @example
 * ```ts
 * const result = await transcribeYouTube("https://youtube.com/watch?v=abc123")
 *
 * if (result.success && result.data) {
 *   // result.data.transcription â†’ transcript text
 *   // result.data.metadata?.title â†’ video title
 * }
 * ```
 */
export async function transcribeYouTube(
  videoUrl: string
): Promise<ServiceResult<VideoTranscription | null>> {
  // Check if Apify is configured
  if (!APIFY_API_TOKEN) {
    return {
      success: true,
      data: null, // Not an error - just not available
    };
  }

  // Extract YouTube video ID
  const videoId = extractYouTubeVideoId(videoUrl);

  if (!videoId) {
    return {
      success: false,
      error: `Invalid YouTube URL: ${videoUrl}`,
    };
  }

  try {
    // Run the Apify actor
    const transcription = await runTranscriptActor(videoId);

    if (!transcription) {
      return {
        success: true,
        data: null,
      };
    }

    return {
      success: true,
      data: {
        sourceUrl: `https://www.youtube.com/watch?v=${videoId}`,
        transcription: transcription.text,
        metadata: {
          videoId: transcription.videoId,
          title: transcription.title,
          description: transcription.description,
          duration: transcription.duration,
          thumbnailUrl: transcription.thumbnailUrl,
          publishedAt: transcription.publishedAt,
          language: transcription.language,
          channelId: transcription.channelId,
          channelName: transcription.channelName,
          subscriberCount: transcription.subscriberCount,
          viewCount: transcription.viewCount,
          likeCount: transcription.likeCount,
          commentCount: transcription.commentCount,
          isAutoGenerated: transcription.isAutoGenerated,
          availableLanguages: transcription.availableLanguages,
        },
      },
    };
  } catch (error) {
    console.error("Error transcribing video:", error);

    // Don't fail the job - return null with success
    return {
      success: true,
      data: null,
    };
  }
}

/**
 * Transcribe multiple YouTube videos.
 *
 * @param videoUrls - Array of YouTube video URLs
 * @returns Service result with combined transcriptions
 */
export async function transcribeMultipleVideos(
  videoUrls: string[]
): Promise<ServiceResult<VideoTranscription[]>> {
  if (!videoUrls.length) {
    return {
      success: true,
      data: [],
    };
  }

  // Process videos sequentially (Apify has rate limits)
  const results: (VideoTranscription | null)[] = [];

  for (const url of videoUrls) {
    const result = await transcribeYouTube(url);
    results.push(result.success ? result.data : null);

    // Small delay between requests
    await new Promise((resolve) => setTimeout(resolve, 500));
  }

  // Filter out nulls
  const validResults = results.filter((r): r is VideoTranscription => r !== null);

  return {
    success: true,
    data: validResults,
  };
}

// ============================================================================
// APIFY ACTOR INTEGRATION
// ============================================================================

/**
 * Run the YouTube Transcript actor on Apify.
 *
 * This function runs the actor synchronously and waits for the result.
 * Extracts ALL available metadata from the YouTube video.
 */
async function runTranscriptActor(
  videoId: string
): Promise<{
  text: string;
  videoId?: string;
  title?: string;
  description?: string;
  duration?: number;
  thumbnailUrl?: string;
  publishedAt?: string;
  language?: string;
  channelId?: string;
  channelName?: string;
  subscriberCount?: number;
  viewCount?: number;
  likeCount?: number;
  commentCount?: number;
  isAutoGenerated?: boolean;
  availableLanguages?: string[];
} | null> {
  try {
    // Prepare input for Apify actor
    const actorInput = {
      youtube_url: `https://www.youtube.com/watch?v=${videoId}`,
      include_transcript_text: true,
    };

    // Start the actor run
    const runResponse = await fetch(
      `${APIFY_API_URL}/${YOUTUBE_TRANSCRIPT_ACTOR_ID}/runs?token=${APIFY_API_TOKEN}`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(actorInput),
      }
    );

    if (!runResponse.ok) {
      const errorText = await runResponse.text();
      console.error("[WIZARD-YOUTUBE] Failed to start Apify actor run", {
        status: runResponse.status,
        statusText: runResponse.statusText,
        actorId: YOUTUBE_TRANSCRIPT_ACTOR_ID,
        responseText: errorText,
      });
      return null;
    }

    const runData = await runResponse.json();
    const runId = runData.data?.id;

    if (!runId) {
      console.error("[WIZARD-YOUTUBE] Apify actor run ID not found in response");
      return null;
    }

    // Wait for the run to complete
    const result = await waitForActorCompletion(runId, 120000); // 2 minutes timeout

    if (!result) {
      return null;
    }

    // Extract transcript from dataset
    const transcript = extractTranscriptFromDataset(runId);

    return transcript;
  } catch (error) {
    console.error("Apify actor error:", error);
    return null;
  }
}

/**
 * Wait for Apify actor run to complete.
 *
 * Polls the run status until it finishes or times out.
 */
async function waitForActorCompletion(
  runId: string,
  timeout: number
): Promise<boolean> {
  const startTime = Date.now();
  const pollInterval = 2000; // Check every 2 seconds

  while (Date.now() - startTime < timeout) {
    try {
      const response = await fetch(
        `${APIFY_API_URL}/${YOUTUBE_TRANSCRIPT_ACTOR_ID}/runs/${runId}?token=${APIFY_API_TOKEN}`
      );

      if (!response.ok) {
        return false;
      }

      const data = await response.json();
      const status = data.data?.status;

      if (status === "SUCCEEDED") {
        return true;
      }

      if (status === "FAILED" || status === "ABORTED" || status === "TIMED-OUT") {
        return false;
      }

      // Still running, wait and poll again
      await new Promise((resolve) => setTimeout(resolve, pollInterval));
    } catch {
      return false;
    }
  }

  return false;
}

/**
 * Extract transcript from Apify dataset.
 *
 * Retrieves the dataset items from the completed run.
 * Extracts ALL available metadata from the YouTube video.
 */
async function extractTranscriptFromDataset(
  runId: string
): Promise<{
  text: string;
  videoId?: string;
  title?: string;
  description?: string;
  duration?: number;
  thumbnailUrl?: string;
  publishedAt?: string;
  language?: string;
  channelId?: string;
  channelName?: string;
  subscriberCount?: number;
  viewCount?: number;
  likeCount?: number;
  commentCount?: number;
  isAutoGenerated?: boolean;
  availableLanguages?: string[];
} | null> {
  try {
    const response = await fetch(
      `${APIFY_API_URL}/${YOUTUBE_TRANSCRIPT_ACTOR_ID}/runs/${runId}/dataset/items?token=${APIFY_API_TOKEN}`
    );

    if (!response.ok) {
      return null;
    }

    const items = await response.json();

    if (!items.data || items.data.length === 0) {
      return null;
    }

    const item = items.data[0];

    // Extract transcript text
    let transcriptText = "";

    if (item.transcript) {
      if (Array.isArray(item.transcript)) {
        transcriptText = item.transcript
          .map((t: { text?: string }) => t.text || "")
          .join(" ");
      } else if (typeof item.transcript === "string") {
        transcriptText = item.transcript;
      }
    }

    // Fallback to subtitles
    if (!transcriptText && item.subtitles) {
      if (Array.isArray(item.subtitles)) {
        transcriptText = item.subtitles
          .map((s: { text?: string }) => s.text || "")
          .join(" ");
      } else if (typeof item.subtitles === "string") {
        transcriptText = item.subtitles;
      }
    }

    if (!transcriptText) {
      return null;
    }

    // Extract ALL available metadata from Apify response
    return {
      text: transcriptText,
      videoId: item.video_id || item.id,
      title: item.title,
      description: item.description,
      duration: item.duration_seconds || item.duration,
      thumbnailUrl: item.thumbnail || item.thumbnailUrl,
      publishedAt: item.published_at || item.timestamp,
      language: item.language,
      channelId: item.channel_id,
      channelName: item.channel_name,
      subscriberCount: item.subscriber_count,
      viewCount: item.view_count,
      likeCount: item.like_count,
      commentCount: item.comment_count,
      isAutoGenerated: item.is_auto_generated,
      availableLanguages: item.available_languages,
    };
  } catch (error) {
    console.error("Error extracting transcript from dataset:", error);
    return null;
  }
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Extract YouTube video ID from various URL formats.
 *
 * Supports:
 * - youtube.com/watch?v=VIDEO_ID
 * - youtu.be/VIDEO_ID
 * - youtube.com/embed/VIDEO_ID
 * - youtube.com/shorts/VIDEO_ID
 * - VIDEO_ID (direct)
 */
export function extractYouTubeVideoId(url: string): string | null {
  // If it's already just a video ID (11 characters)
  if (/^[a-zA-Z0-9_-]{11}$/.test(url)) {
    return url;
  }

  try {
    const urlObj = new URL(url);

    // Handle youtu.be short URLs
    if (urlObj.hostname === "youtu.be") {
      return urlObj.pathname.slice(1);
    }

    // Handle youtube.com URLs
    if (urlObj.hostname.includes("youtube.com")) {
      // Check for watch?v= parameter
      const watchParam = urlObj.searchParams.get("v");
      if (watchParam) {
        return watchParam;
      }

      // Check for embed/VIDEO_ID format
      const embedMatch = urlObj.pathname.match(/^\/embed\/([a-zA-Z0-9_-]{11})/);
      if (embedMatch) {
        return embedMatch[1];
      }

      // Check for shorts/VIDEO_ID format
      const shortsMatch = urlObj.pathname.match(/^\/shorts\/([a-zA-Z0-9_-]{11})/);
      if (shortsMatch) {
        return shortsMatch[1];
      }
    }

    return null;
  } catch {
    return null;
  }
}

/**
 * Check if a URL is a valid YouTube URL.
 */
export function isYouTubeUrl(url: string): boolean {
  return !!extractYouTubeVideoId(url);
}

/**
 * Get thumbnail URL for a YouTube video.
 *
 * Returns the maxresdefault (high quality) thumbnail.
 */
export function getYouTubeThumbnail(videoId: string): string {
  return `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`;
}

// ============================================================================
// FORMATTING FUNCTIONS
// ============================================================================

/**
 * Format YouTube transcription data for inclusion in LLM prompts.
 *
 * Creates a structured, readable representation of all YouTube metadata
 * that helps the AI understand the context and create better content.
 *
 * @param transcription - VideoTranscription object from transcribeYouTube()
 * @returns Formatted string for prompt inclusion
 *
 * @example
 * ```ts
 * const result = await transcribeYouTube("https://youtube.com/watch?v=abc123")
 *
 * if (result.success && result.data) {
 *   const formatted = formatYouTubeForPrompt(result.data)
 *   // â†’ Returns structured string with all video metadata + transcript
 * }
 * ```
 */
export function formatYouTubeForPrompt(
  transcription: VideoTranscription
): string {
  const parts: string[] = [];

  parts.push("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
  parts.push("VÃDEO DO YOUTUBE ANALISADO");
  parts.push("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
  parts.push("");

  // Basic video info
  if (transcription.metadata?.title) {
    parts.push(`ğŸ“º TÃTULO: ${transcription.metadata.title}`);
  }
  if (transcription.metadata?.channelName) {
    parts.push(`ğŸ‘¤ CANAL: ${transcription.metadata.channelName}`);
  }

  // Engagement metrics (formatted with K/M notation)
  const metrics: string[] = [];
  if (transcription.metadata?.viewCount) {
    metrics.push(`${formatNumber(transcription.metadata.viewCount)} views`);
  }
  if (transcription.metadata?.likeCount) {
    metrics.push(`${formatNumber(transcription.metadata.likeCount)} likes`);
  }
  if (transcription.metadata?.commentCount) {
    metrics.push(`${formatNumber(transcription.metadata.commentCount)} comentÃ¡rios`);
  }
  if (metrics.length > 0) {
    parts.push(`ğŸ“Š ENGAJAMENTO: ${metrics.join(" â€¢ ")}`);
  }

  // Channel authority
  if (transcription.metadata?.subscriberCount) {
    parts.push(`ğŸ‘¥ INSCRITOS: ${formatNumber(transcription.metadata.subscriberCount)}`);
  }

  // Video details
  const details: string[] = [];
  if (transcription.metadata?.duration) {
    const minutes = Math.floor(transcription.metadata.duration / 60);
    const seconds = transcription.metadata.duration % 60;
    details.push(`${minutes}:${seconds.toString().padStart(2, "0")}`);
  }
  if (transcription.metadata?.publishedAt) {
    const date = new Date(transcription.metadata.publishedAt);
    details.push(date.toLocaleDateString("pt-BR"));
  }
  if (transcription.metadata?.language) {
    details.push(transcription.metadata.language.toUpperCase());
  }
  if (details.length > 0) {
    parts.push(`ğŸ“… DETALHES: ${details.join(" â€¢ ")}`);
  }

  // URL
  parts.push(`ğŸ”— LINK: ${transcription.sourceUrl}`);
  parts.push("");

  // Description (truncated if too long)
  if (transcription.metadata?.description) {
    const desc = transcription.metadata.description;
    const truncated = desc.length > 500
      ? desc.substring(0, 500) + "..."
      : desc;
    parts.push("ğŸ“ DESCRIÃ‡ÃƒO:");
    parts.push(truncated);
    parts.push("");
  }

  // Transcript
  parts.push("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
  parts.push("TRANSCRIÃ‡ÃƒO COMPLETA:");
  parts.push("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
  parts.push("");
  parts.push(transcription.transcription);
  parts.push("");
  parts.push("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

  return parts.join("\n");
}

/**
 * Format large numbers with K/M suffix for better readability.
 *
 * @example
 * formatNumber(1500) // "1.5K"
 * formatNumber(1500000) // "1.5M"
 * formatNumber(500) // "500"
 */
function formatNumber(num: number): string {
  if (num >= 1000000) {
    return (num / 1000000).toFixed(1).replace(".0", "") + "M";
  }
  if (num >= 1000) {
    return (num / 1000).toFixed(1).replace(".0", "") + "K";
  }
  return num.toString();
}
